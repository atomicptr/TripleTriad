local cards = require "main.data.cards"

local AI = require "main.ai.smart"
local Rng = require "modules.rng"
local Grid = require "modules.grid"

local Pos = Grid.Pos

---@class Action
---@field row Pos
---@field col Pos
---@field card Card
---@field player boolean

---@enum State
local State = {
    GAME_START = 0,
    PLAYER_HAND = 1,
    PLAYER_FIELD = 2,
    BATTLE_PHASE = 3,
    ENEMY_TURN = 4,
    GAME_END = 5,
}

---@class Game
---@field state State
---@field field table<Pos, table<Pos, OwnedCard|nil>>
---@field player_turn boolean
---@field player_hand integer[]
---@field enemy_hand integer[]
---@field enemy_plan EnemyPlan|nil
---@field hand_selected integer|nil
---@field flipping boolean
---@field action_log Action[]
---@field time float

---@param self Game
function init(self)
    self.state = State.GAME_START
    self.field = nil
    self.time = 0

    msg.post("#music", "play_sound", { gain = 0.2 })

    msg.post(".", "acquire_input_focus")
end

---@param self Game
---@return { player: integer, enemy: integer }
local function count_score(self)
    local score = {
        player = 0,
        enemy = 0,
    }

    for _, row in pairs(self.field) do
        for _, card in pairs(row) do
            if card then
                if card.player then
                    score.player = score.player + 1
                else
                    score.enemy = score.enemy + 1
                end
            end
        end
    end

    return score
end

---@param self Game
local function end_battle_phase(self)
    if #self.player_hand == 0 or #self.enemy_hand == 0 then
        self.state = State.GAME_END
        return
    end

    if self.player_turn then
        self.state = State.ENEMY_TURN

        -- enemy has no cards for some reason? Go to player
        if #self.enemy_hand == 0 then
            msg.post("/hand_player", "init")
            self.state = State.PLAYER_HAND
            return
        end

        -- TODO: send message to enemy something
    else
        self.state = State.PLAYER_HAND

        -- player has no cards for some reason? Go to enemy
        if #self.player_hand == 0 then
            msg.post("/cursor", "hide")
            self.state = State.ENEMY_TURN
            return
        end

        msg.post("/hand_player", "init")
    end
end

---@param self Game
---@param dt float
function update(self, dt)
    self.time = self.time + dt

    if self.state == State.GAME_START then
        Rng.init()

        self.hand_selected = nil

        self.time = 0
        self.action_log = {}
        self.flipping = false

        msg.post("/board", "reset")

        -- TODO: figure out decks somehow
        self.player_hand = {
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
        }
        self.enemy_hand = {
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
        }

        self.field = {
            [Pos.North] = {
                [Pos.West] = nil,
                [Pos.Center] = nil,
                [Pos.East] = nil,
            },
            [Pos.Center] = {
                [Pos.West] = nil,
                [Pos.Center] = nil,
                [Pos.East] = nil,
            },
            [Pos.South] = {
                [Pos.West] = nil,
                [Pos.Center] = nil,
                [Pos.East] = nil,
            },
        }

        msg.post("/hand_player", "set_cards", {
            cards = self.player_hand,
        })

        msg.post("/hand_enemy", "set_cards", {
            cards = self.enemy_hand,
        })

        self.player_turn = Rng.flip_coin()
        print("Player turn?", self.player_turn)

        if self.player_turn then
            self.state = State.PLAYER_HAND
            msg.post("/hand_player", "init")
            return
        end

        self.state = State.ENEMY_TURN
    elseif self.state == State.PLAYER_HAND then
        self.player_turn = true
    elseif self.state == State.PLAYER_FIELD then
    elseif self.state == State.BATTLE_PHASE then
        if self.flipping then
            return
        end

        local last_action = self.action_log[#self.action_log]

        local new_card = last_action.card

        local orthogonal_cards = get_orthogonal_cards(self, last_action.row, last_action.col)

        ---@type OwnedCard[]
        local flip_cards = {}

        for _, c in ipairs(orthogonal_cards) do
            -- only evaluate cards that aren't "your own"
            if c.value.player ~= self.player_turn then
                local enemy_card = c.value.card

                -- TODO: handle SAME ruleset
                if c.direction == "up" and new_card.top > enemy_card.bottom then
                    table.insert(flip_cards, c.value)
                elseif c.direction == "down" and new_card.bottom > enemy_card.top then
                    table.insert(flip_cards, c.value)
                elseif c.direction == "left" and new_card.left > enemy_card.right then
                    table.insert(flip_cards, c.value)
                elseif c.direction == "right" and new_card.right > enemy_card.left then
                    table.insert(flip_cards, c.value)
                end
            end
        end

        if #flip_cards > 0 then
            self.flipping = true

            -- flip in data model
            for _, card in ipairs(flip_cards) do
                self.field[card.row][card.col].player = not self.field[card.row][card.col].player
            end

            msg.post("/board", "flip_cards", {
                cards = flip_cards,
                player = self.player_turn,
            })

            return
        end

        -- TODO: handle effects or something

        -- ending battle phase
        end_battle_phase(self)
    elseif self.state == State.ENEMY_TURN then
        self.player_turn = false

        if self.enemy_plan then
            -- continue the plan
            return
        end

        self.enemy_plan = AI.calculate(self.enemy_hand, self.field)
        assert(self.enemy_plan ~= nil)

        -- wait a bit
        timer.delay(0.1, false, function()
            msg.post("/hand_enemy", "enemy_select", {
                index = self.enemy_plan.hand_index,
            })
        end)
    elseif self.state == State.GAME_END then
        local score = count_score(self)

        pprint("Score: ", score)

        if score.player == score.enemy then
            msg.post("/gameover", "gameover", { result = "draw" })
        elseif score.player > score.enemy then
            msg.post("/gameover", "gameover", { result = "win" })
        else
            msg.post("/gameover", "gameover", { result = "lose" })
        end
    end
end

---@param self Game
---@param direction "up"|"down"|"left"|"right"
function move_cursor(self, direction)
    if self.state == State.PLAYER_HAND then
        if direction == "left" or direction == "right" then
            return
        end

        msg.post("/hand_player", "move_cursor", {
            direction = direction,
        })

        play_sound "select"
    elseif self.state == State.PLAYER_FIELD then
        msg.post("/board", "move_cursor", {
            direction = direction,
        })

        play_sound "select"
    end
end

---@param self Game
function select_action(self)
    if self.state == State.PLAYER_HAND then
        msg.post("/hand_player", "select")
    elseif self.state == State.PLAYER_FIELD then
        msg.post("/board", "select")
    elseif self.state == State.GAME_END then
        self.state = State.GAME_START

        msg.post("/gameover", "restart")
    end
end

---@param self Game
function cancel_action(self)
    if self.state == State.PLAYER_FIELD then
        self.state = State.PLAYER_HAND
        msg.post("/hand_player", "init", {
            dont_reset_index = true,
        })

        play_sound "cancel"
    end
end

---@param self Game
---@param action_id hash
---@param action table
function on_input(self, action_id, action)
    if action.pressed and action_id == hash "move_up" then
        move_cursor(self, "up")
    elseif action.pressed and action_id == hash "move_down" then
        move_cursor(self, "down")
    elseif action.pressed and action_id == hash "move_left" then
        move_cursor(self, "left")
    elseif action.pressed and action_id == hash "move_right" then
        move_cursor(self, "right")
    elseif action.pressed and action_id == hash "select" then
        select_action(self)
    elseif action.pressed and action_id == hash "cancel" then
        cancel_action(self)
    end
end

---@param self Game
---@param message_id hash
---@param message table
---@param sender hash
function on_message(self, message_id, message, sender)
    if message_id == hash "board_request_place_card" then
        pprint "game: board_request_place_card"

        if not self.field[message.row][message.col] then
            msg.post(sender, "place_card", {
                player_card = self.player_turn,
            })
            return
        else
            play_sound "forbidden"
        end
    elseif message_id == hash "board_place_card_finished" then
        pprint "game: board_place_card_finished"

        self.field[message.row][message.col] = {
            card = cards[message.card],
            player = self.player_turn,
            row = message.row,
            col = message.col,
        }

        msg.post("/cursor", "hide")

        local action = {
            row = message.row,
            col = message.col,
            card = cards[message.card],
            player = self.player_turn,
        }

        table.insert(self.action_log, action)

        if self.player_turn then
            table.remove(self.player_hand, self.hand_selected)

            msg.post("/hand_player", "remove_card", {
                index = self.hand_selected,
            })

            self.hand_selected = nil
        else
            table.remove(self.enemy_hand, self.enemy_plan.hand_index)

            msg.post("/hand_enemy", "remove_card", {
                index = self.enemy_plan.hand_index,
            })

            self.enemy_plan = nil
            self.hand_selected = nil
        end

        play_sound "card"
    elseif message_id == hash "hand_selected_card" then
        pprint "game: hand_selected_card"

        self.state = State.PLAYER_FIELD

        self.hand_selected = message.index

        local card_id = self.player_hand[message.index]

        msg.post("/board", "init", {
            selected_card = card_id,
        })
    elseif message_id == hash "hand_enemy_selected_card" then
        pprint "game: hand_enemy_selected_card"

        assert(self.enemy_plan ~= nil)
        self.hand_selected = self.enemy_plan.hand_index

        local card_id = self.enemy_hand[self.enemy_plan.hand_index]

        msg.post("/board", "enemy_place", {
            selected_card = card_id,
            row = self.enemy_plan.target_pos.row,
            col = self.enemy_plan.target_pos.col,
        })
    elseif message_id == hash "hand_card_removed" then
        pprint "game: hand_card_removed"

        self.state = State.BATTLE_PHASE
    elseif message_id == hash "board_finished_flipping" then
        self.flipping = false
        end_battle_phase(self)
    elseif message_id == hash "card_flipped" then
        play_sound "capture"
    end
end

---@param self Game
---@param row Pos
---@param col Pos
---@return { value: OwnedCard, direction: "up"|"down"|"left"|"right" }[]
function get_orthogonal_cards(self, row, col)
    local ortho_cards = {}

    for _, pos in ipairs(Grid.orthogonal(row, col)) do
        local card = self.field[pos.row][pos.col]

        if card then
            table.insert(ortho_cards, {
                value = card,
                direction = pos.direction,
            })
        end
    end

    return ortho_cards
end

---@param self Game
---@return Action
function last_action(self)
    return self.action_log[#self.action_log]
end

---@param name string
function play_sound(name)
    msg.post("/sfx#" .. name, "play_sound", { gain = 0.2 })
end
