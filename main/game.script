local cards = require "main.data.cards"
local tbl = require "modules.tbl"
local combat = require "main.combat"

local AI = require "main.ai.smart"
local Rng = require "modules.rng"
local Grid = require "modules.grid"
local Ruleset = require "main.data.rulesets"
local Element = require "main.data.elements"

---@class Action
---@field row Pos
---@field col Pos
---@field card Card
---@field player boolean

---@enum State
local State = {
    GAME_START = 0,
    PLAYER_HAND = 1,
    PLAYER_FIELD = 2,
    BATTLE_PHASE = 3,
    ENEMY_TURN = 4,
    GAME_END = 5,
}

---@class Game
---@field state State
---@field field GameField
---@field player_turn boolean
---@field player_hand integer[]
---@field enemy_hand integer[]
---@field enemy_plan EnemyPlan|nil
---@field hand_selected integer|nil
---@field flipping boolean
---@field action_log Action[]
---@field time float
---@field rules Ruleset[]
---@field element_placement ElementPlacement[]

---@param self Game
function init(self)
    Rng.init()

    self.state = State.GAME_START
    self.field = nil
    self.time = 0

    msg.post("#music", "play_sound", { gain = 0.2 })

    msg.post(".", "acquire_input_focus")
end

---@param self Game
---@return { player: integer, enemy: integer }
local function count_score(self)
    local score = {
        player = 0,
        enemy = 0,
    }

    for _, row in pairs(self.field) do
        for _, card in pairs(row) do
            if card.owner == "player" then
                score.player = score.player + 1
            elseif card.owner == "enemy" then
                score.enemy = score.enemy + 1
            end
        end
    end

    return score
end

---@param self Game
local function end_battle_phase(self)
    if #self.player_hand == 0 or #self.enemy_hand == 0 then
        self.state = State.GAME_END
        return
    end

    if self.player_turn then
        self.state = State.ENEMY_TURN

        -- enemy has no cards for some reason? Go to player
        if #self.enemy_hand == 0 then
            msg.post("/hand_player", "init")
            self.state = State.PLAYER_HAND
            return
        end

        -- TODO: send message to enemy something
    else
        self.state = State.PLAYER_HAND

        -- player has no cards for some reason? Go to enemy
        if #self.player_hand == 0 then
            msg.post("/cursor", "hide")
            self.state = State.ENEMY_TURN
            return
        end

        msg.post("/hand_player", "init")
    end
end

---@param self Game
---@param dt float
function update(self, dt)
    self.time = self.time + dt

    local is_element = tbl.contains(self.rules or {}, Ruleset.Elemental)

    if self.state == State.GAME_START then
        self.hand_selected = nil

        self.time = 0
        self.action_log = {}
        self.flipping = false

        self.rules = {
            Ruleset.Open,
            Ruleset.Elemental,
        }

        -- do this AFTER setting rules :)
        is_element = tbl.contains(self.rules or {}, Ruleset.Elemental)

        -- apply rulesets
        msg.post("/hand_enemy", "apply_rules", {
            rules = self.rules,
        })

        self.element_placement = {}

        if is_element then
            Grid.for_each(function(row, col)
                if Rng.chance(0.3) then
                    table.insert(self.element_placement, {
                        pos = { row = row, col = col },
                        element = Rng.enum(Element),
                    })
                end
            end)
        end

        msg.post("/board", "reset", {
            rules = self.rules,
            element_placements = self.element_placement,
        })

        -- TODO: figure out decks somehow
        self.player_hand = {
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
        }
        self.enemy_hand = {
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
            Rng.draw_index(cards),
        }

        self.field = Grid.create(function(row, col)
            local element = nil

            if is_element then
                for _, epos in ipairs(self.element_placement) do
                    if epos.pos.row == row and epos.pos.col == col then
                        element = epos.element
                        break
                    end
                end
            end

            ---@type CardSlot
            return {
                card = nil,
                row = row,
                col = col,
                element = element,
            }
        end)

        msg.post("/hand_player", "set_cards", {
            cards = self.player_hand,
        })

        msg.post("/hand_enemy", "set_cards", {
            cards = self.enemy_hand,
        })

        self.player_turn = false
        -- self.player_turn = Rng.flip_coin()
        print("Player turn?", self.player_turn)

        if self.player_turn then
            self.state = State.PLAYER_HAND
            msg.post("/hand_player", "init")
            return
        end

        self.state = State.ENEMY_TURN
    elseif self.state == State.PLAYER_HAND then
        self.player_turn = true
    elseif self.state == State.PLAYER_FIELD then
    elseif self.state == State.BATTLE_PHASE then
        if self.flipping then
            return
        end

        local last_action = self.action_log[#self.action_log]

        local new_card = last_action.card
        local new_card_field_element = nil

        if is_element then
            new_card_field_element = self.field[last_action.row][last_action.col].element
        end

        local new_card_vals = combat.card_values(new_card, new_card_field_element)

        local orthogonal_cards = get_orthogonal_cards(self, last_action.row, last_action.col)

        ---@type CardSlot[]
        local flip_cards = {}

        -- TODO: refactor combat evaluation into function
        for _, c in ipairs(orthogonal_cards) do
            -- only evaluate cards that aren't "your own"
            if (self.player_turn and c.value.owner == "enemy") or c.value.owner == "player" then
                local enemy_card = c.value.card

                if not enemy_card then
                    goto continue
                end

                local enemy_card_field_element = nil

                if is_element then
                    enemy_card_field_element = self.field[c.value.row][c.value.col].element
                end

                local enemy_card_vals = combat.card_values(enemy_card, enemy_card_field_element)

                -- TODO: handle rulesets
                if c.direction == "up" and new_card_vals.top > enemy_card_vals.bottom then
                    table.insert(flip_cards, c.value)
                elseif c.direction == "down" and new_card_vals.bottom > enemy_card_vals.top then
                    table.insert(flip_cards, c.value)
                elseif c.direction == "left" and new_card_vals.left > enemy_card_vals.right then
                    table.insert(flip_cards, c.value)
                elseif c.direction == "right" and new_card_vals.right > enemy_card_vals.left then
                    table.insert(flip_cards, c.value)
                end
            end

            ::continue::
        end

        if #flip_cards > 0 then
            self.flipping = true

            -- flip in data model
            for _, card in ipairs(flip_cards) do
                local owner = self.field[card.row][card.col].owner

                if owner == "player" then
                    self.field[card.row][card.col].owner = "enemy"
                else
                    self.field[card.row][card.col].owner = "player"
                end
            end

            msg.post("/board", "flip_cards", {
                cards = flip_cards,
                player = self.player_turn,
            })

            return
        end

        -- TODO: handle effects or something

        -- ending battle phase
        end_battle_phase(self)
    elseif self.state == State.ENEMY_TURN then
        self.player_turn = false

        if self.enemy_plan then
            -- continue the plan
            return
        end

        self.enemy_plan = AI.calculate(self.enemy_hand, self.field, self.rules)
        assert(self.enemy_plan)
        assert(self.enemy_plan.hand_index)
        assert(self.enemy_plan.target_pos)

        -- wait a bit
        timer.delay(0.1, false, function()
            msg.post("/hand_enemy", "enemy_select", {
                index = self.enemy_plan.hand_index,
            })
        end)
    elseif self.state == State.GAME_END then
        local score = count_score(self)

        -- TODO: dont just open gameover but animate it into

        pprint("Score: ", score)

        if score.player == score.enemy then
            msg.post("/gameover", "gameover", { result = "draw" })
        elseif score.player > score.enemy then
            msg.post("/gameover", "gameover", { result = "win" })
        else
            msg.post("/gameover", "gameover", { result = "lose" })
        end
    end
end

---@param self Game
---@param direction "up"|"down"|"left"|"right"
function move_cursor(self, direction)
    if self.state == State.PLAYER_HAND then
        if direction == "left" or direction == "right" then
            return
        end

        msg.post("/hand_player", "move_cursor", {
            direction = direction,
        })

        play_sound "select"
    elseif self.state == State.PLAYER_FIELD then
        msg.post("/board", "move_cursor", {
            direction = direction,
        })

        play_sound "select"
    end
end

---@param self Game
function select_action(self)
    if self.state == State.PLAYER_HAND then
        msg.post("/hand_player", "select")
    elseif self.state == State.PLAYER_FIELD then
        msg.post("/board", "select")
    elseif self.state == State.GAME_END then
        self.state = State.GAME_START

        msg.post("/gameover", "restart")
    end
end

---@param self Game
function cancel_action(self)
    if self.state == State.PLAYER_FIELD then
        self.state = State.PLAYER_HAND
        msg.post("/hand_player", "init", {
            dont_reset_index = true,
        })

        play_sound "cancel"
    end
end

---@param self Game
---@param action_id hash
---@param action table
function on_input(self, action_id, action)
    if action.pressed and action_id == hash "move_up" then
        move_cursor(self, "up")
    elseif action.pressed and action_id == hash "move_down" then
        move_cursor(self, "down")
    elseif action.pressed and action_id == hash "move_left" then
        move_cursor(self, "left")
    elseif action.pressed and action_id == hash "move_right" then
        move_cursor(self, "right")
    elseif action.pressed and action_id == hash "select" then
        select_action(self)
    elseif action.pressed and action_id == hash "cancel" then
        cancel_action(self)
    end
end

---@param self Game
---@param message_id hash
---@param message table
---@param sender hash
function on_message(self, message_id, message, sender)
    if message_id == hash "board_request_place_card" then
        pprint("game: board_request_place_card", message)

        if not self.field[message.row][message.col].card then
            msg.post(sender, "place_card", {
                player_card = self.player_turn,
            })
            return
        else
            play_sound "forbidden"
        end
    elseif message_id == hash "board_place_card_finished" then
        pprint("game: board_place_card_finished", message)

        self.field[message.row][message.col].card = cards[message.card]

        if self.player_turn then
            self.field[message.row][message.col].owner = "player"
        else
            self.field[message.row][message.col].owner = "enemy"
        end

        if tbl.contains(self.rules, Ruleset.Elemental) then
            local element = self.field[message.row][message.col].element

            if element then
                local modifier = -1

                if element == self.field[message.row][message.col].card.element then
                    modifier = 1
                end

                msg.post(message.id, "set_modifier", {
                    modifier = modifier,
                })
            end
        end

        msg.post("/cursor", "hide")

        local action = {
            row = message.row,
            col = message.col,
            card = cards[message.card],
            player = self.player_turn,
        }

        table.insert(self.action_log, action)

        if self.player_turn then
            table.remove(self.player_hand, self.hand_selected)

            msg.post("/hand_player", "remove_card", {
                index = self.hand_selected,
            })

            self.hand_selected = nil
        else
            table.remove(self.enemy_hand, self.enemy_plan.hand_index)

            msg.post("/hand_enemy", "remove_card", {
                index = self.enemy_plan.hand_index,
            })

            self.enemy_plan = nil
            self.hand_selected = nil
        end

        play_sound "card"
    elseif message_id == hash "hand_selected_card" then
        pprint("game: hand_selected_card", message)

        self.state = State.PLAYER_FIELD

        self.hand_selected = message.index

        local card_id = self.player_hand[message.index]

        msg.post("/board", "init", {
            selected_card = card_id,
        })
    elseif message_id == hash "hand_enemy_selected_card" then
        pprint("game: hand_enemy_selected_card", message)

        assert(self.enemy_plan)
        assert(self.enemy_plan.hand_index)
        assert(self.enemy_plan.target_pos)

        self.hand_selected = self.enemy_plan.hand_index

        local card_id = self.enemy_hand[self.enemy_plan.hand_index]

        msg.post("/board", "enemy_place", {
            selected_card = card_id,
            row = self.enemy_plan.target_pos.row,
            col = self.enemy_plan.target_pos.col,
        })
    elseif message_id == hash "hand_card_removed" then
        pprint("game: hand_card_removed", message)

        self.state = State.BATTLE_PHASE
    elseif message_id == hash "board_finished_flipping" then
        pprint("game: board_finished_flipping", message)

        self.flipping = false
        end_battle_phase(self)
    elseif message_id == hash "card_flipped" then
        pprint("game: card_flipped", message)

        play_sound "capture"
    end
end

---@param self Game
---@param row Pos
---@param col Pos
---@return { value: CardSlot, direction: "up"|"down"|"left"|"right" }[]
function get_orthogonal_cards(self, row, col)
    local ortho_cards = {}

    for _, pos in ipairs(Grid.orthogonal(row, col)) do
        local card = self.field[pos.row][pos.col]

        if card then
            table.insert(ortho_cards, {
                value = card,
                direction = pos.direction,
            })
        end
    end

    return ortho_cards
end

---@param self Game
---@return Action
function last_action(self)
    return self.action_log[#self.action_log]
end

---@param name string
function play_sound(name)
    msg.post("/sfx#" .. name, "play_sound", { gain = 0.2 })
end
