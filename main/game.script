local cards = require "main.data.cards"
local tbl = require "modules.tbl"
local combat = require "main.combat"

local AI = require "main.ai.smart"
local Rng = require "modules.rng"
local Grid = require "modules.grid"
local Ruleset = require "main.data.rulesets"
local Element = require "main.data.elements"

---@class Action
---@field row Pos
---@field col Pos
---@field card Card
---@field player boolean

---@enum State
local State = {
    GAME_START = 1,
    PLAYER_HAND = 2,
    PLAYER_FIELD = 3,
    BATTLE_PHASE = 4,
    ENEMY_TURN = 5,
    GAME_END = 6,
}

---@type Scenario
local SCENARIO = nil
-- local SCENARIO = require("main.data.scenario").TestSameCombo
-- local SCENARIO = require("main.data.scenario").TestPlusCombo
-- local SCENARIO = require("main.data.scenario").ElementStuff
-- local SCENARIO = require("main.data.scenario").FullFieldFlip

---@class Game
---@field state State
---@field field GameField
---@field player_turn boolean
---@field player_hand integer[]
---@field enemy_hand integer[]
---@field enemy_plan EnemyPlan|nil
---@field hand_selected integer|nil
---@field flipping bool
---@field flip_groups FlipGroup[]
---@field action_log Action[]
---@field time float
---@field rules Ruleset[]
---@field element_placement ElementPlacement[]
---@field can_end boolean
---@field end_started boolean
---@field setup_cards { card_id: integer, pos: BoardPos, owner: "player"|"enemy" }[]
---@field mouse_mode boolean
---@field mouse_pos vector3
---@field drag_object hash|nil
---@field drag_orig_pos vector3
---@field hand_hovering hash|nil

---@param self Game
function init(self)
    Rng.init()

    self.state = State.GAME_START
    self.field = nil
    self.time = 0
    self.mouse_mode = false
    self.mouse_pos = vmath.vector3(0)
    self.drag_orig_pos = vmath.vector3(0)

    msg.post("#music", "play_sound", { gain = 0.2 })

    msg.post(".", "acquire_input_focus")
end

---@param self Game
---@return { player: integer, enemy: integer }
local function count_score(self)
    local score = {
        player = 0,
        enemy = 0,
    }

    for _, row in pairs(self.field) do
        for _, card in pairs(row) do
            if card.owner == "player" then
                score.player = score.player + 1
            elseif card.owner == "enemy" then
                score.enemy = score.enemy + 1
            end
        end
    end

    return score
end

---@param self Game
local function reset_game(self)
    self.hand_selected = nil

    self.time = 0
    self.action_log = {}
    self.flipping = false
    self.flip_groups = {}
    self.can_end = false
    self.end_started = false
    self.element_placement = {}
    self.setup_cards = {}
    self.drag_object = nil
end

---@param self Game
local function setup_game(self)
    reset_game(self)

    self.rules = {
        Ruleset.Elemental,
        Ruleset.Same,
        Ruleset.Plus,
    }

    -- do this AFTER setting rules :)
    is_element = tbl.contains(self.rules or {}, Ruleset.Elemental)

    if is_element then
        Grid.for_each(function(row, col)
            if Rng.chance(0.3) then
                table.insert(self.element_placement, {
                    pos = { row = row, col = col },
                    element = Rng.enum(Element),
                })
            end
        end)
    end

    -- TODO: figure out decks somehow
    self.player_hand = {
        Rng.draw_index(cards),
        Rng.draw_index(cards),
        Rng.draw_index(cards),
        Rng.draw_index(cards),
        Rng.draw_index(cards),
    }

    self.enemy_hand = {
        Rng.draw_index(cards),
        Rng.draw_index(cards),
        Rng.draw_index(cards),
        Rng.draw_index(cards),
        Rng.draw_index(cards),
    }

    self.field = Grid.create(function(row, col)
        local element = nil

        if is_element then
            for _, epos in ipairs(self.element_placement) do
                if epos.pos.row == row and epos.pos.col == col then
                    element = epos.element
                    break
                end
            end
        end

        ---@type CardSlot
        return {
            card = nil,
            row = row,
            col = col,
            element = element,
        }
    end)

    self.player_turn = Rng.flip_coin()
end

---@param self Game
local function setup_scenario(self)
    reset_game(self)

    assert(SCENARIO)

    self.rules = SCENARIO.rules

    Grid.for_each(function(row, col)
        table.insert(self.element_placement, {
            pos = { row = row, col = col },
            element = SCENARIO.field[row][col].element,
        })

        if SCENARIO.field[row][col].card then
            table.insert(self.setup_cards, {
                card_id = SCENARIO.field[row][col].card.id,
                pos = { row = row, col = col },
                owner = SCENARIO.field[row][col].owner,
            })
        end
    end)

    self.player_hand = SCENARIO.player_hand
    self.enemy_hand = SCENARIO.enemy_hand

    self.field = SCENARIO.field

    self.player_turn = SCENARIO.start_turn == "player"
end

---@param self Game
local function end_battle_phase(self)
    -- update scores
    local score = count_score(self)

    msg.post("/hand_player", "set_score", { score = score.player })
    msg.post("/hand_enemy", "set_score", { score = score.enemy })

    if tbl.count(self.player_hand) == 0 or tbl.count(self.enemy_hand) == 0 then
        self.state = State.GAME_END
        return
    end

    local is_game_done = Grid.fold(function(acc, row, col)
        if self.field[row][col].card == nil then
            return acc
        end

        return acc + 1
    end, 0) == 9

    if is_game_done then
        self.state = State.GAME_END
        return
    end

    if self.player_turn then
        self.state = State.ENEMY_TURN

        -- enemy has no cards for some reason? Go to player
        if tbl.count(self.enemy_hand) == 0 then
            if not self.mouse_mode then
                msg.post("/hand_player", "init")
            end
            self.state = State.PLAYER_HAND
            return
        end
    else
        self.state = State.PLAYER_HAND

        -- player has no cards for some reason? Go to enemy
        if tbl.count(self.player_hand) == 0 then
            msg.post("/cursor", "hide")
            self.state = State.ENEMY_TURN
            return
        end

        if not self.mouse_mode then
            msg.post("/hand_player", "init")
        end
    end
end

---@param self Game
---@param dt float
function update(self, dt)
    self.time = self.time + dt

    if self.state == State.GAME_START then
        if SCENARIO then
            setup_scenario(self)
        else
            setup_game(self)
        end

        -- doesnt contain combo, but a rule requires combo
        if not tbl.contains(self.rules, Ruleset.Combo) then
            if tbl.contains(self.rules, Ruleset.Same) or tbl.contains(self.rules, Ruleset.Plus) then
                table.insert(self.rules, Ruleset.Combo)
            end
        end

        -- apply rulesets
        msg.post("/hand_enemy", "apply_rules", {
            rules = self.rules,
        })

        msg.post("/board", "reset", {
            rules = self.rules,
            element_placements = self.element_placement,
        })

        msg.post("/hand_player", "set_cards", {
            cards = self.player_hand,
        })

        msg.post("/hand_enemy", "set_cards", {
            cards = self.enemy_hand,
        })

        -- spawn setup cards
        for _, setup_card in ipairs(self.setup_cards) do
            msg.post("/board", "setup_spawn_card", {
                card_id = setup_card.card_id,
                card_pos = setup_card.pos,
                owner = setup_card.owner,
            })
        end

        -- reset scores
        msg.post("/hand_player", "set_score", { score = 0 })
        msg.post("/hand_enemy", "set_score", { score = 0 })

        print("Player turn?", self.player_turn)

        if self.player_turn then
            self.state = State.PLAYER_HAND
            if not self.mouse_mode then
                self.hand_selected = 1
                msg.post("/hand_player", "init")
            end
            return
        end

        self.state = State.ENEMY_TURN
    elseif self.state == State.PLAYER_HAND then
        self.player_turn = true
    elseif self.state == State.PLAYER_FIELD then
    elseif self.state == State.BATTLE_PHASE then
        if self.flipping then
            return
        end

        self.flip_groups = {}

        local last_action = self.action_log[#self.action_log]

        local owner = "enemy"

        if last_action.player then
            owner = "player"
        end

        local new_card = last_action.card
        local new_card_pos = { row = last_action.row, col = last_action.col }

        local flip_cards = combat.process_combat(new_card, new_card_pos, self.field, self.rules)

        if tbl.count(flip_cards) > 0 then
            table.insert(self.flip_groups, { animation = nil, targets = flip_cards })
        end

        if tbl.contains(self.rules, Ruleset.Same) then
            local same_captures = {}
            local same_new_captures = {}

            for _, fc in ipairs(combat.process_same(new_card, new_card_pos, self.field, self.rules)) do
                local is_new = tbl.some(flip_cards, function(item)
                    return fc.row == item.row and fc.col == item.col
                end)

                table.insert(same_captures, fc)

                if not is_new then
                    table.insert(same_new_captures, fc)
                end
            end

            if tbl.count(same_new_captures) > 0 then
                pprint("SAME:", same_new_captures)
                table.insert(self.flip_groups, { animation = "same", targets = same_new_captures })
            end

            -- process combo
            local captures = same_captures
            while true do
                local combo_captures = {}

                for _, fc in ipairs(combat.process_combo(owner, captures, self.field, self.rules)) do
                    local is_new = tbl.some(flip_cards, function(item)
                        return fc.row == item.row and fc.col == item.col
                    end)

                    if not is_new then
                        table.insert(combo_captures, fc)
                    end
                end

                if tbl.count(combo_captures) > 0 then
                    pprint("COMBO:", combo_captures)
                    table.insert(self.flip_groups, { animation = "combo", targets = combo_captures })

                    captures = combo_captures
                else
                    break
                end
            end
        end

        if tbl.contains(self.rules, Ruleset.Plus) then
            local plus_captures = {}
            local plus_new_captures = {}

            for _, fc in ipairs(combat.process_plus(new_card, new_card_pos, self.field, self.rules)) do
                local is_new = tbl.some(flip_cards, function(item)
                    return fc.row == item.row and fc.col == item.col
                end)

                table.insert(plus_captures, fc)

                if not is_new then
                    table.insert(plus_new_captures, fc)
                end
            end

            if tbl.count(plus_new_captures) > 0 then
                pprint("PLUS:", plus_new_captures)
                table.insert(self.flip_groups, { animation = "plus", targets = plus_new_captures })
            end

            -- process combo
            local captures = plus_captures
            while true do
                local combo_captures = {}

                for _, fc in ipairs(combat.process_combo(owner, captures, self.field, self.rules)) do
                    local is_new = tbl.some(flip_cards, function(item)
                        return fc.row == item.row and fc.col == item.col
                    end)

                    if not is_new then
                        table.insert(combo_captures, fc)
                    end
                end

                if tbl.count(combo_captures) > 0 then
                    pprint("COMBO:", combo_captures)
                    table.insert(self.flip_groups, { animation = "combo", targets = combo_captures })

                    captures = combo_captures
                else
                    break
                end
            end
        end

        if tbl.count(self.flip_groups) > 0 then
            msg.post(".", "pop_flip_group")
            return
        end

        -- if nothing to flip, switch
        end_battle_phase(self)
    elseif self.state == State.ENEMY_TURN then
        self.player_turn = false

        if self.enemy_plan then
            -- continue the plan
            return
        end

        self.enemy_plan = AI.calculate(self.enemy_hand, self.field, self.rules)
        assert(self.enemy_plan)
        assert(self.enemy_plan.hand_index)
        assert(self.enemy_plan.target_pos)

        -- wait a bit
        timer.delay(0.1, false, function()
            msg.post("/hand_enemy", "enemy_select", {
                index = self.enemy_plan.hand_index,
            })
        end)
    elseif self.state == State.GAME_END then
        local score = count_score(self)

        if not self.end_started then
            self.end_started = true
            pprint("Score: ", score, self.can_end)

            if score.player == score.enemy then
                msg.post("/gameover", "gameover", { result = "draw" })
            elseif score.player > score.enemy then
                msg.post("/gameover", "gameover", { result = "win" })
            else
                msg.post("/gameover", "gameover", { result = "lose" })
            end
        end
    end

    if self.drag_object then
        msg.post(self.drag_object, "dragging", {
            pos = self.mouse_pos,
        })
        msg.post("/board", "pointer_move", {
            mouse_pos = self.mouse_pos,
        })
    end
end

---@param self Game
---@param direction "up"|"down"|"left"|"right"
function move_cursor(self, direction)
    if self.state == State.PLAYER_HAND then
        if direction == "left" or direction == "right" then
            return
        end

        msg.post("/hand_player", "move_cursor", {
            direction = direction,
        })

        play_sound "select"
    elseif self.state == State.PLAYER_FIELD then
        msg.post("/board", "move_cursor", {
            direction = direction,
        })

        play_sound "select"
    end
end

---@param self Game
function select_action(self)
    if self.state == State.PLAYER_HAND then
        msg.post("/hand_player", "select")
    elseif self.state == State.PLAYER_FIELD then
        msg.post("/board", "select")
    elseif self.state == State.GAME_END then
        self.state = State.GAME_START

        msg.post("/gameover", "restart")
    end
end

---@param self Game
function cancel_action(self)
    if self.state == State.PLAYER_FIELD then
        self.state = State.PLAYER_HAND

        if self.mouse_mode then
            return
        end

        msg.post("/hand_player", "init", {
            dont_reset_index = true,
        })

        play_sound "cancel"
    end
end

---@param self Game
local function disable_mouse_mode(self)
    if self.mouse_mode then
        self.hand_selected = 1
        msg.post("/hand_player", "init")
    end
    self.mouse_mode = false
end

---@param self Game
---@param action_id hash
---@param action table
function on_input(self, action_id, action)
    if action.pressed and action_id == hash "click" then
        self.mouse_mode = true
        self.hand_selected = nil
        msg.post("/cursor", "hide")
    end

    if self.mouse_mode and action.screen_x and action.screen_y then
        self.mouse_pos.x = action.screen_x
        self.mouse_pos.y = action.screen_y

        if not self.drag_object then
            msg.post("/hand_player", "pointer_move", {
                mouse_pos = self.mouse_pos,
            })
        end
    end

    if action.pressed and action_id == hash "move_up" then
        disable_mouse_mode(self)
        move_cursor(self, "up")
    elseif action.pressed and action_id == hash "move_down" then
        disable_mouse_mode(self)
        move_cursor(self, "down")
    elseif action.pressed and action_id == hash "move_left" then
        disable_mouse_mode(self)
        move_cursor(self, "left")
    elseif action.pressed and action_id == hash "move_right" then
        disable_mouse_mode(self)
        move_cursor(self, "right")
    elseif action.pressed and action_id == hash "select" then
        select_action(self)
    elseif action.pressed and action_id == hash "cancel" then
        cancel_action(self)
    elseif self.mouse_mode and action_id == hash "click" then
        if self.state == State.PLAYER_HAND then
            if action.pressed then
                msg.post("/hand_player", "drag_started", { mouse_pos = self.mouse_pos })
            elseif action.released and self.drag_object then
                msg.post("/board", "dragging_request_drop", { pos = self.mouse_pos })
            end
        elseif self.state == State.GAME_END and self.can_end then
            select_action(self)
        end
    end
end

---@param self Game
---@param message_id hash
---@param message table
---@param sender hash
function on_message(self, message_id, message, sender)
    if message_id == hash "board_request_place_card" then
        pprint("game: board_request_place_card", message)

        if not self.field[message.row][message.col].card then
            msg.post(sender, "place_card", {
                player_card = self.player_turn,
            })
            return
        else
            play_sound "forbidden"
        end
    elseif message_id == hash "board_place_card_finished" then
        pprint("game: board_place_card_finished", message)

        self.field[message.row][message.col].card = cards[message.card]

        if self.player_turn then
            self.field[message.row][message.col].owner = "player"
        else
            self.field[message.row][message.col].owner = "enemy"
        end

        if tbl.contains(self.rules, Ruleset.Elemental) then
            local element = self.field[message.row][message.col].element

            if element then
                local modifier = -1

                if element == self.field[message.row][message.col].card.element then
                    modifier = 1
                end

                msg.post(message.id, "set_modifier", {
                    modifier = modifier,
                })
            end
        end

        msg.post("/cursor", "hide")

        local action = {
            row = message.row,
            col = message.col,
            card = cards[message.card],
            player = self.player_turn,
        }

        table.insert(self.action_log, action)

        if self.player_turn then
            table.remove(self.player_hand, self.hand_selected)

            msg.post("/hand_player", "remove_card", {
                index = self.hand_selected,
            })

            self.hand_selected = nil
        else
            table.remove(self.enemy_hand, self.enemy_plan.hand_index)

            msg.post("/hand_enemy", "remove_card", {
                index = self.enemy_plan.hand_index,
            })

            self.enemy_plan = nil
            self.hand_selected = nil
        end

        play_sound "card"

        self.drag_object = nil
    elseif message_id == hash "hand_selected_card" then
        pprint("game: hand_selected_card", message)

        self.state = State.PLAYER_FIELD

        self.hand_selected = message.index

        local card_id = self.player_hand[message.index]

        msg.post("/board", "init", {
            selected_card = card_id,
        })
    elseif message_id == hash "hand_enemy_selected_card" then
        pprint("game: hand_enemy_selected_card", message)

        assert(self.enemy_plan)
        assert(self.enemy_plan.hand_index)
        assert(self.enemy_plan.target_pos)

        self.hand_selected = self.enemy_plan.hand_index

        local card_id = self.enemy_hand[self.enemy_plan.hand_index]

        msg.post("/board", "enemy_place", {
            selected_card = card_id,
            row = self.enemy_plan.target_pos.row,
            col = self.enemy_plan.target_pos.col,
        })
    elseif message_id == hash "hand_card_removed" then
        pprint("game: hand_card_removed", message)

        self.state = State.BATTLE_PHASE
    elseif message_id == hash "board_finished_flipping" then
        pprint("game: board_finished_flipping", message)

        if tbl.count(self.flip_groups) > 0 then
            msg.post(".", "pop_flip_group")
            return
        end

        self.flipping = false
        end_battle_phase(self)
    elseif message_id == hash "card_flipped" then
        pprint("game: card_flipped", message)

        local score = count_score(self)

        msg.post("/hand_player", "set_score", { score = score.player })
        msg.post("/hand_enemy", "set_score", { score = score.enemy })

        play_sound "capture"
    elseif message_id == hash "pop_flip_group" then
        self.flipping = true

        local flip_group = table.remove(self.flip_groups, 1)

        local current_owner = "enemy"
        if self.player_turn then
            current_owner = "player"
        end

        local targets = flip_group.targets

        -- change owner to current in targets
        for _, card in ipairs(targets) do
            self.field[card.row][card.col].owner = current_owner
        end

        if flip_group.animation then
            msg.post("/capturefx", "flip_cards", {
                animation = flip_group.animation,
                targets = targets,
            })

            if flip_group.animation == "combo" then
                play_sound "combo"
            end
        else
            msg.post("/board", "flip_cards", {
                targets = targets,
            })
        end
    elseif message_id == hash "hand_drag_started" then
        pprint("game: hand_drag_started", message)

        self.drag_object = message.object
        self.drag_orig_pos = message.orig_pos
        self.hand_selected = message.hand_index

        if self.hand_hovering then
            msg.post(self.hand_hovering, "hovering_stop")
            self.hand_hovering = nil
        end
    elseif message_id == hash "card_drag_ended" then
        pprint("game: card_drag_ended", message)

        self.drag_object = nil
    elseif message_id == hash "board_drop_response" then
        pprint("game: board_drop_response", message)

        if message.granted then
            if not self.field[message.row][message.col].card then
                self.hand_hovering = nil
                msg.post("/board", "place_card", {
                    player_card = true,
                    row = message.row,
                    col = message.col,
                    card_id = self.player_hand[self.hand_selected],
                })
            else
                play_sound "forbidden"
            end
        end

        msg.post(self.drag_object, "drag_ended", { orig_pos = self.drag_orig_pos })
    elseif message_id == hash "hand_hover_card" then
        if self.hand_hovering then
            msg.post(self.hand_hovering, "hovering_stop")
            self.hand_hovering = nil
        end

        if not message.object then
            return
        end

        self.hand_hovering = message.object
        msg.post(message.object, "hovering_start")
    elseif message_id == hash "gameover_can_end" then
        self.can_end = true
    end
end

---@param self Game
---@return Action
function last_action(self)
    return self.action_log[#self.action_log]
end

---@param name string
function play_sound(name)
    msg.post("/sfx#" .. name, "play_sound", { gain = 0.2 })
end
