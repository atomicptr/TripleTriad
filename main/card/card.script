local Element = require "main.data.elements"
local cards = require "main.data.cards"
local camera = require "orthographic.camera"

go.property("card_id", 1)
go.property("player_card", false)
go.property("visible", true)

---@param rank integer
---@return hash
local function card_rank(rank)
    if rank >= 10 then
        return hash "A"
    end
    if rank <= 0 then
        return hash "0"
    end
    return hash(tostring(rank))
end

---@param element Element
---@return hash
local function element_hash(element)
    if element == Element.Earth then
        return hash "earth"
    elseif element == Element.Fire then
        return hash "fire"
    elseif element == Element.Holy then
        return hash "holy"
    elseif element == Element.Ice then
        return hash "ice"
    elseif element == Element.Poison then
        return hash "poison"
    elseif element == Element.Thunder then
        return hash "thunder"
    elseif element == Element.Water then
        return hash "water"
    elseif element == Element.Wind then
        return hash "wind"
    end

    return hash "unreachable"
end

local function setup_card(self)
    self.card = cards[self.card_id]

    if not self.visible then
        sprite.play_flipbook("#front", hash "card-back")
        msg.post("#back", "disable")

        msg.post("#rank_top", "disable")
        msg.post("#rank_bottom", "disable")
        msg.post("#rank_left", "disable")
        msg.post("#rank_right", "disable")

        msg.post("#element", "disable")
        msg.post("#elementmod", "disable")
        return
    end

    sprite.play_flipbook("#front", hash(self.card_id))

    sprite.play_flipbook("#rank_top", card_rank(self.card.top + self.modifier))
    sprite.play_flipbook("#rank_bottom", card_rank(self.card.bottom + self.modifier))
    sprite.play_flipbook("#rank_left", card_rank(self.card.left + self.modifier))
    sprite.play_flipbook("#rank_right", card_rank(self.card.right + self.modifier))

    if self.card.element then
        sprite.play_flipbook("#element", element_hash(self.card.element))
    else
        msg.post("#element", "disable")
    end

    if self.modifier ~= 0 then
        msg.post("#elementmod", "enable")

        if self.modifier > 0 then
            sprite.play_flipbook("#elementmod", "element-positive-text")
        else
            sprite.play_flipbook("#elementmod", "element-negative-text")
        end
    else
        msg.post("#elementmod", "disable")
    end
end

local function set_background(self)
    if self.player_card then
        sprite.play_flipbook("#back", "card-back-player")
    else
        sprite.play_flipbook("#back", "card-back-enemy")
    end
end

function init(self)
    self.modifier = 0
    self.z = go.get_position().z

    set_background(self)
    setup_card(self)
end

---@param self table
---@param message_id hash
---@param message table
---@param sender hash
function on_message(self, message_id, message, sender)
    if message_id == hash "flip" then
        pprint("card: flip", message)

        self.player_card = not self.player_card
        set_background(self)

        msg.post("/game", "card_flipped")

        go.animate(".", "scale.x", go.PLAYBACK_ONCE_PINGPONG, 0, go.EASING_INBOUNCE, 0.2, 0.0, function()
            msg.post("/board", "card_finished_flipping")
        end)
    elseif message_id == hash "set_modifier" then
        self.modifier = message.modifier or 0
        setup_card(self)
    elseif message_id == hash "dragging" then
        local pos = camera.screen_to_world(nil, message.pos)
        go.set_position(vmath.vector3(pos.x, pos.y, 75))
    elseif message_id == hash "drag_ended" then
        pprint("card: drag_ended", message, sender)

        go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, message.orig_pos, go.EASING_LINEAR, 0.1, 0.0, function()
            msg.post("/game", "card_drag_ended")
        end)
    elseif message_id == hash "hovering_start" then
        go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(1.2, 1.2, 1), go.EASING_LINEAR, 0.1, 0.0)
        local pos = go.get_position()
        go.set_position(vmath.vector3(pos.x, pos.y, 65))
    elseif message_id == hash "hovering_stop" then
        go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(1, 1, 1), go.EASING_LINEAR, 0.1, 0.0)
        local pos = go.get_position()
        go.set_position(vmath.vector3(pos.x, pos.y, self.z))
    end
end
