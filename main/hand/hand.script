local Ruleset = require "main.data.rulesets"
local tbl = require "modules.tbl"
local screen = require "main.screen"
local math2 = require "modules.math2"

go.property("player_hand", false)

---@class Hand
---@field player_hand boolean
---@field cards_visible boolean
---@field cards hash[]
---@field selected_index integer
---@field mouse_dragging hash|nil
---@field mouse_pos vector3

---@param self Hand
function init(self)
    msg.post("#score", "disable")

    self.cards_visible = self.player_hand

    self.cards = {}
    self.selected_index = 1
end

---@param self Hand
---@param cards integer[]
function set_cards(self, cards)
    -- delete old cards
    for _, card_id in ipairs(self.cards) do
        go.delete(card_id)
    end

    -- instanciate new cards
    for _, card_id in ipairs(cards) do
        local id = factory.create("#card_factory", nil, nil, {
            card_id = card_id,
            player_card = self.player_hand,
            visible = self.cards_visible,
        })
        table.insert(self.cards, id)
    end

    order_cards(self)
end

---@param self Hand
function order_cards(self)
    local pos = go.get_position()

    for index, card in ipairs(self.cards) do
        local x = 0

        if self.selected_index == index then
            x = -32

            msg.post("/cursor", "move", {
                target_pos = pos + vmath.vector3(x, 0, 0),
                skip_anim = false,
            })
        end

        go.set_position(pos + vmath.vector3(x, 0, 0), card)

        pos = pos + vmath.vector3(0, 100, -1)
    end
end

---@param self Hand
---@param direction "up"|"down"
local function apply_cursor_movement(self, direction)
    if direction == "up" then
        if self.selected_index == tbl.count(self.cards) then
            self.selected_index = 1
        else
            self.selected_index = self.selected_index + 1
        end
    elseif direction == "down" then
        if self.selected_index <= 1 then
            self.selected_index = tbl.count(self.cards)
        else
            self.selected_index = self.selected_index - 1
        end
    end
end

---@param self Hand
---@return vector3
function selected_position(self)
    local card = self.cards[self.selected_index]
    return go.get_position(card)
end

---@param self Hand
---@param message_id hash
---@param message table
---@param sender hash
function on_message(self, message_id, message, sender)
    if message_id == hash "set_cards" then
        pprint("hand: set_cards", message)

        if self.cards then
            for _, card in ipairs(self.cards) do
                go.delete(card)
            end
        end

        self.selected_index = nil
        self.cards = {}
        set_cards(self, message.cards)
    elseif message_id == hash "init" then
        pprint("hand: init", message)

        if not (message.dont_reset_index or false) then
            self.selected_index = 1
        end

        msg.post("/cursor", "move", {
            target_pos = selected_position(self),
            skip_anim = true,
        })
        order_cards(self)
    elseif message_id == hash "move_cursor" then
        pprint("hand: move_cursor", message)

        apply_cursor_movement(self, message.direction)
        order_cards(self)
    elseif message_id == hash "select" then
        pprint("hand: select", message)

        msg.post(sender, "hand_selected_card", {
            index = self.selected_index,
        })
    elseif message_id == hash "enemy_select" then
        pprint("hand: enemy_select", message)

        self.selected_index = message.index
        order_cards(self)

        msg.post(sender, "hand_enemy_selected_card")
    elseif message_id == hash "remove_card" then
        pprint("hand: remove_card", message)

        self.selected_index = nil
        local card = table.remove(self.cards, message.index)
        go.delete(card)
        order_cards(self)

        msg.post(sender, "hand_card_removed")
    elseif message_id == hash "apply_rules" then
        pprint("hand: apply_rules", message)

        local is_open = tbl.contains(message.rules, Ruleset.Open)

        if is_open then
            self.cards_visible = true
        end
    elseif message_id == hash "set_score" then
        pprint("hand: set_score", message)

        if message.score <= 0 then
            msg.post("#score", "disable")
            return
        end

        msg.post("#score", "enable")

        local score = math.min(9, message.score)
        sprite.play_flipbook("#score", string.format("%i", score))
    elseif message_id == hash "pointer_move" then
        local pos = message.mouse_pos

        self.selected_index = nil
        order_cards(self)

        for _, card_id in ipairs(self.cards) do
            local card_pos = go.get_world_position(card_id)
            local card_screen_pos = screen.world_to_screen(card_pos)

            if math2.point_in_rect(pos, card_screen_pos, 200) then
                msg.post(sender, "hand_hover_card", {
                    object = card_id,
                })
                return
            end
        end

        msg.post(sender, "hand_hover_card") -- to tell game that its over
    elseif message_id == hash "drag_started" then
        pprint("hand: drag_started", message)

        for index, card_id in ipairs(self.cards) do
            local card_pos = go.get_world_position(card_id)
            local card_screen_pos = screen.world_to_screen(card_pos)

            if math2.point_in_rect(message.mouse_pos, card_screen_pos, 200) then
                local pos = go.get_position(card_id)

                msg.post(sender, "hand_drag_started", {
                    object = card_id,
                    hand_index = index,
                    orig_pos = pos,
                })
                return
            end
        end
    end
end
